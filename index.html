<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EPUB Library</title>
  <style>
    <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EPUB Library</title>
  <style>
  :root {
    /* Slytherin palette */
    --emerald: #0b5d3b;      /* primary green */
    --gold: #d5a53a;         /* accent gold */
    --black: #050608;        /* near-black */
    --silver: #c7c9ce;       /* main light text / borders */
    --grey-light: #e3e4e8;   /* light backgrounds */
    --grey-mid: #9ca0a8;     /* muted text */
    --grey-dark: #3b3f46;    /* card background */
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    max-width: 900px;
    margin: 2rem auto;
    padding: 0 1rem 3rem;
    line-height: 1.5;

    /* overall page */
    background-color: var(--grey-dark);
    color: var(--silver);
  }

  h1 {
    margin-bottom: 0.5rem;
    color: var(--silver);
    letter-spacing: 0.08em;
    text-transform: uppercase;
  }

  h1 span {
    color: var(--emerald);
  }

  p {
    color: var(--grey-light);
  }

  a {
    color: var(--gold);
    text-decoration: none;
    border-bottom: 1px solid transparent;
  }

  a:hover {
    border-bottom-color: var(--gold);
  }

  .search-area {
  margin: 1.5rem 0 2rem;
  padding: 1rem 1.25rem;
  border-radius: 0.75rem;

  /* Solid color */
  background-color: #0b5d3b; /* emerald */

  border: 1px solid rgba(199, 201, 206, 0.25);
}

/* Input becomes light-on-dark for readability */
#searchInput {
  width: 97%;
  padding: 0.55rem 0.7rem;
  border-radius: 0.5rem;

  background-color: #a6c8bb;     /* deep charcoal */
  border: 1px solid #3a3f46;     /* medium grey */
  color: #181515;                /* light text */

  -webkit-appearance: none !important;   /* overrides iOS Safari */
  appearance: none !important;
}

#searchInput::placeholder {
  color: #b7b7b7 !important;             /* softer grey */
}



  label {
    display: block;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: var(--silver);
    margin-bottom: 0.35rem;
  }

  input[type="text"] {
    width: 100%;
    padding: 0.55rem 0.7rem;
    border-radius: 0.5rem;
    border: 1px solid var(--grey-dark);
    background-color: #111318;
    color: var(--grey-light);
  }

  input[type="text"]:focus {
    outline: none;
    border-color: var(--emerald);
    box-shadow: 0 0 0 1px rgba(11, 93, 59, 0.4);
  }

  /* fic result card */
  .fic {
  background:
    radial-gradient(
      circle at 10% 10%,
      rgba(199, 201, 206, 0.07),
      rgba(0, 0, 0, 0)
    ),
    #0b5d3b; /* deep slate grey base */

  border: 2px solid #d4af37; /* gold border */
  border-radius: 0.75rem;
  padding: 1rem 1.25rem;
  margin-bottom: 1rem;

  box-shadow: 0 2px 8px rgba(0,0,0,0.45);
  color: #e6e6e6;
}

.fic h2 {
  margin: 0 0 0.4rem;
  font-size: 1.1rem;
  color: #0d0b0b;
}

.summary {
  color: #d0d0d0;
}

.meta {
  color: #b5b7bb;
}


  /* tags */
  .tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.35rem;
    margin-top: 0.4rem;
  }

 .tag {
  font-size: 0.8rem;
  padding: 0.15rem 0.5rem;
  border-radius: 999px;

  background-color: #d7d9dd; /* light silver */
  color: #0b5d3b;            /* emerald text */
  border: 1px solid #bfc1c5; /* soft grey */
}


  /* Cort rec badge */
  .corts {
    margin-top: 0.5rem;
  }

  .cort-badge {
    display: inline-block;
    padding: 0.18rem 0.6rem;
    border-radius: 999px;

    background: linear-gradient(
      90deg,
      var(--emerald),
      var(--gold)
    );
    color: #fff;
    font-weight: 600;
    font-size: 0.78rem;
    letter-spacing: 0.06em;
    text-transform: uppercase;
  }

  /* "No results" / error state */
  .empty {
    color: var(--grey-mid);
    font-style: italic;
    margin-top: 1rem;
  }
</style>


</head>
<body>
  <h1>Book Club EPUB Library</h1>
  <p style="margin-top: -0.4rem; margin-bottom: 1.5rem; font-size: 0.9rem; color: #123617;">
  Hosted by <strong>Cort</strong>, <strong>Deydralinne</strong>, <strong>Lexi</strong>, and <strong>Senna</strong>
</p>
  <div class="search-area">
    <label for="searchInput"><strong>Search</strong> (title, author, tags, etc.):</label><br />
    <input id="searchInput" type="text" placeholder="Start typing: drarry, coffee shop, author name..." />
    <p style="font-size:0.9rem; color:#144319; margin-top:0.35rem;">
      This search looks at Title, Author, Main Relationship, Summary, Tags, and Corts Tiktok Recs.
    </p>
  </div>

  <div id="results"></div>

  <script>
  // üîó Your published Google Sheet (TSV)
  const SHEET_URL =
    "https://docs.google.com/spreadsheets/d/e/2PACX-1vSw2PTQY-cYcZm02BVyXM5opvi7Exun9P0qLFtQvb6Lv5ByPb6vnpsi3lls_hAEyJ6m1hlWXv9pPvgT/pub?gid=162465043&single=true&output=tsv";

  // üìö This will hold all your fics from the sheet
  let library = [];

  // üîó Grab elements from the page
  const resultsContainer = document.getElementById("results");
  const searchInput = document.getElementById("searchInput");
  const cortsFilter = document.getElementById("cortsFilter"); // ok if this doesn't exist

  // üßπ Safely lowercase text
  function normalize(value) {
    return (value || "").toString().toLowerCase();
  }

  // üéØ Does this fic match the search text?
  function matchesQuery(item, query) {
    if (!query) return true;
    const q = normalize(query);

    return (
      normalize(item.title).includes(q) ||
      normalize(item.author).includes(q) ||
      normalize(item.mainRelationship).includes(q) ||
      normalize(item.summary).includes(q) ||
      normalize((item.tags || []).join(" ")).includes(q) ||
      normalize(item.cortsTiktokRecs).includes(q)
    );
  }

  // (optional) extra filtering for Cort's recs, if you add a dropdown
  function matchesCortsFilter(item) {
    if (!cortsFilter || !cortsFilter.value || cortsFilter.value === "all") {
      return true;
    }

    if (cortsFilter.value === "corts-only") {
      // Treat anything not FALSE/empty as a rec
      return normalize(item.cortsTiktokRecs) && normalize(item.cortsTiktokRecs) !== "false";
    }

    return true;
  }

  // üñºÔ∏è Render the fic list into the page
  function renderResults(items) {
    if (!resultsContainer) return;

    if (!items.length) {
      resultsContainer.innerHTML =
        '<p class="empty">No results. Try a different search term.</p>';
      return;
    }

   const html = items
  .map((item) => {
    const titleHtml = item.linkOnServer
      ? `<a href="${item.linkOnServer}" target="_blank" rel="noopener noreferrer">${item.title}</a>`
      : item.title;

    const tagsHtml =
      item.tags && item.tags.length
        ? item.tags.map((t) => `<span class="tag">${t}</span>`).join(" ")
        : "";

    // Decide if this is a real Cort Rec (checked box in the sheet)
    const isCortRec = normalize(item.cortsTiktokRecs) === "true";

    const cortsHtml = isCortRec
      ? `<div class="corts"><span class="cort-badge">‚úÖ Cort Rec</span></div>`
      : "";

    return `
      <article class="fic">
        <h2>${titleHtml}</h2>
        <div class="meta">
          <span><strong>Author:</strong> ${item.author || "Unknown"}</span>
          <span><strong>Words:</strong> ${item.words || "?"}</span>
          <span><strong>Chapters:</strong> ${item.chapters || "?"}</span>
          <span><strong>Main Relationship:</strong> ${item.mainRelationship || "‚Äî"}</span>
        </div>
        <p class="summary">${item.summary || ""}</p>
        <div class="tags">${tagsHtml}</div>
        ${cortsHtml}
      </article>
    `;
  })
  .join("");


    resultsContainer.innerHTML = html;
  }
  // üé≤ Pick up to "count" random items from an array
  function getRandomItems(items, count) {
    const copy = [...items]; // shallow copy so we don't mutate the original

    // Fisher‚ÄìYates shuffle
    for (let i = copy.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }

    return copy.slice(0, Math.min(count, copy.length));
  }

  // üîé Apply search + Cort's filter to the library and show results
  function applyFilters() {
    if (!library.length) {
      // no data yet
      if (resultsContainer) {
        resultsContainer.innerHTML = "<p class='empty'>Loading‚Ä¶</p>";
      }
      return;
    }

    const query = searchInput ? searchInput.value.trim() : "";

    // Always respect the Cort's filter first (if you use it)
    let filtered = library.filter((item) => matchesCortsFilter(item));

    if (query) {
      // If there's a search term: filter by text and show ALL matches
      filtered = filtered.filter((item) => matchesQuery(item, query));
      renderResults(filtered);
    } else {
      // If search box is empty: show 5 random fics from the filtered list
      const randomFive = getRandomItems(filtered, 5);
      renderResults(randomFive);
    }
  }


  // üì• Load data from the Google Sheet
  async function loadSheetData() {
    console.log("Fetching sheet from:", SHEET_URL);
    const response = await fetch(SHEET_URL);

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status} ${response.statusText}`);
    }

    const text = await response.text();
    console.log("Raw sheet text (first 200 chars):", text.slice(0, 200));

    const rows = text
      .trim()
      .split("\n")
      .map((row) => row.split("\t"));

    const [headerRow, ...dataRows] = rows;
    console.log("Headers:", headerRow);

    library = dataRows.map((cols) => {
      const [
        title,
        linkOnServer,
        author,
        words,
        chapters,
        mainRelationship,
        summary,
        tags,
        cortsTiktokRecs,
      ] = cols;

      return {
        title: title || "",
        linkOnServer: linkOnServer || "",
        author: author || "",
        words: words || "",
        chapters: chapters || "",
        mainRelationship: mainRelationship || "",
        summary: summary || "",
        tags: tags ? tags.split(",").map((t) => t.trim()) : [],
        cortsTiktokRecs: cortsTiktokRecs || "",
      };
    });

    console.log("Loaded items:", library.length);
  }

  // üîÅ Wire up events
if (searchInput) {
  const triggerFilter = () => {
    applyFilters();
  };

  // Fire filters for a bunch of interaction types (better mobile support)
  ["input", "keyup", "change", "search"].forEach((evt) => {
    searchInput.addEventListener(evt, triggerFilter);
  });
}

if (cortsFilter) {
  cortsFilter.addEventListener("change", () => {
    applyFilters();
  });
}

  </script>
</body>
</html>


