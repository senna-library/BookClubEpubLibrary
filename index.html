<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EPUB Library</title>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-KQWDJX5K5P"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-KQWDJX5K5P');
  </script>

  <style>
  :root {
    /* Dark Academia Slytherin palette */
    --forest-green: #1a3a2e;    /* deep forest green */
    --emerald: #2d5f4c;         /* rich emerald */
    --sage: #4a7c59;            /* muted sage green */
    --antique-gold: #c9a961;    /* aged brass/gold */
    --deep-gold: #a0894f;       /* darker gold accent */
    --parchment: #f4f1e8;       /* cream/parchment text */
    --aged-paper: #e8e3d3;      /* aged paper */
    --charcoal: #1a2520;        /* very dark green */
    --dark-brown: #162b22;      /* darker forest green */
    --bronze: #8b7355;          /* bronze/brown accent */
  }

  body {
    font-family: 'Garamond', 'Georgia', serif;
    max-width: 900px;
    margin: 2rem auto;
    padding: 0 1rem 3rem;
    line-height: 1.6;

    /* Dark academia background */
    background-color: var(--charcoal);
    color: var(--parchment);
  }

  h1 {
    margin-bottom: 0.5rem;
    color: var(--parchment);
    letter-spacing: 0.08em;
    text-transform: uppercase;
    font-family: 'Georgia', serif;
  }

  h1 span {
    color: var(--antique-gold);
  }

  p {
    color: var(--aged-paper);
  }

  a {
    color: var(--antique-gold);
    text-decoration: none;
    border-bottom: 1px solid transparent;
    transition: all 0.2s ease;
  }

  a:hover {
    border-bottom-color: var(--antique-gold);
    color: var(--deep-gold);
  }

  .search-area {
  margin: 1.5rem 0 2rem;
  padding: 1.25rem 1.5rem;
  border-radius: 0.5rem;

  background: linear-gradient(
    135deg,
    var(--emerald),
    var(--sage)
  );
  border: 2px solid var(--antique-gold);
  box-shadow:
    0 4px 12px rgba(0, 0, 0, 0.5),
    0 0 20px rgba(201, 169, 97, 0.15);
}

#searchInput {
  width: 97%;
  padding: 0.65rem 0.85rem;
  border-radius: 0.4rem;

  background-color: #2a3d34;
  border: 1px solid var(--sage);
  color: var(--parchment);
  font-family: 'Georgia', serif;

  -webkit-appearance: none !important;
  appearance: none !important;
}

#searchInput::placeholder {
  color: var(--aged-paper) !important;
}



  label {
    display: block;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: var(--parchment);
    margin-bottom: 0.35rem;
    font-family: 'Georgia', serif;
  }

  input[type="text"] {
    width: 100%;
    padding: 0.65rem 0.85rem;
    border-radius: 0.4rem;
    border: 1px solid var(--sage);
    background-color: #2a3d34;
    color: var(--parchment);
    font-family: 'Georgia', serif;
  }

  input[type="text"]:focus {
    outline: none;
    border-color: var(--antique-gold);
    box-shadow: 0 0 0 2px rgba(201, 169, 97, 0.3);
  }

  select {
    width: 100%;
    padding: 0.65rem 0.85rem;
    border-radius: 0.4rem;
    border: 1px solid var(--sage);
    background-color: #2a3d34;
    color: var(--parchment);
    font-family: 'Georgia', serif;
    cursor: pointer;
  }

  select:focus {
    outline: none;
    border-color: var(--antique-gold);
    box-shadow: 0 0 0 2px rgba(201, 169, 97, 0.3);
  }

  /* fic result card */
  .fic {
  position: relative; /* for absolute positioning of badge */
  background: #c8e4d4;
  border: 2px solid #8fb89a;
  border-radius: 0.5rem;
  padding: 1rem 1.5rem 1.25rem;
  margin-bottom: 1.25rem;

  box-shadow:
    0 4px 12px rgba(0, 0, 0, 0.3),
    inset 0 1px 0 rgba(255, 255, 255, 0.5);
  color: #2a2a2a;
}

.fic h2 {
  margin: 0 0 0.5rem;
  font-size: 1.4rem;
  color: var(--deep-gold);
  font-family: 'Georgia', serif;
  font-weight: 600;
}

.fic h2 a {
  transition: all 0.2s ease;
  color: var(--deep-gold);
}

.fic h2 a:hover {
  color: var(--antique-gold);
  text-shadow: none;
}

.summary {
  color: #3a3a3a;
  font-style: normal;
  line-height: 1.6;
}

.meta {
  color: #4a4a4a;
  font-size: 0.9rem;
  margin-bottom: 0.5rem;
}


  /* tags */
  .tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
    margin-top: 0.6rem;
  }

 .tag {
  font-size: 0.75rem;
  padding: 0.25rem 0.6rem;
  border-radius: 0.3rem;

  background-color: var(--forest-green);
  color: var(--antique-gold);
  border: 1px solid #2a2a2a;
  font-family: 'Georgia', serif;
  text-transform: lowercase;
  letter-spacing: 0.02em;
}


  /* Cort rec badge */
  .corts {
    position: absolute;
    top: 0.25rem;
    right: 0.5rem;
  }

  .cort-badge {
    display: block;
    max-width: 70px;
    height: auto;
  }

  /* "No results" / error state */
  .empty {
    color: var(--aged-paper);
    font-style: italic;
    margin-top: 1rem;
    font-family: 'Georgia', serif;
  }

  /* Library count */
  .library-count {
    color: var(--sage);
    font-family: 'Georgia', serif;
    font-size: 0.9rem;
    margin-bottom: 1.5rem;
    font-style: italic;
  }

  .library-count strong {
    color: var(--antique-gold);
  }

  /* Random Rec Button */
  .random-btn {
    float: right;
    margin-top: 0.5rem;
    padding: 0.4rem 0.8rem;
    border: 1.5px solid #000;
    border-radius: 0.3rem;
    background-color: var(--forest-green);
    color: var(--antique-gold);
    font-family: 'Georgia', serif;
    font-size: 0.85rem;
    font-weight: 600;
    text-transform: lowercase;
    letter-spacing: 0.02em;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .random-btn:hover {
    background-color: var(--emerald);
    border-color: #000;
  }

  .random-btn:active {
    transform: scale(0.98);
  }

  /* Christmas Lights */
  .christmas-lights {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 40px;
    display: flex;
    justify-content: space-around;
    align-items: flex-end;
    padding: 0 2rem;
    z-index: 1000;
    background: transparent;
  }

  .light {
    width: 12px;
    height: 16px;
    border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
    position: relative;
    animation: twinkle 1.5s infinite;
  }

  .light::before {
    content: '';
    position: absolute;
    top: -4px;
    left: 50%;
    transform: translateX(-50%);
    width: 2px;
    height: 8px;
    background: #333;
  }

  .light.red {
    background: radial-gradient(circle, #ff4444, #cc0000);
    box-shadow: 0 0 10px #ff4444;
    animation-delay: 0s;
  }

  .light.green {
    background: radial-gradient(circle, #44ff44, #00cc00);
    box-shadow: 0 0 10px #44ff44;
    animation-delay: 0.3s;
  }

  .light.yellow {
    background: radial-gradient(circle, #ffff44, #ffcc00);
    box-shadow: 0 0 10px #ffff44;
    animation-delay: 0.6s;
  }

  .light.blue {
    background: radial-gradient(circle, #4444ff, #0000cc);
    box-shadow: 0 0 10px #4444ff;
    animation-delay: 0.9s;
  }

  @keyframes twinkle {
    0%, 100% {
      opacity: 1;
      filter: brightness(1);
    }
    50% {
      opacity: 0.4;
      filter: brightness(0.6);
    }
  }

  /* Featured Lists */
  .featured-section {
    margin: 1.5rem 0;
    padding: 1.25rem 1.5rem;
    border-radius: 0.5rem;
    border: 2px solid var(--sage);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  }

  .featured-section h3 {
    margin: 0 0 1rem;
    font-size: 1.3rem;
    color: var(--antique-gold);
    font-family: 'Georgia', serif;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }

  .dramione-section {
    background: linear-gradient(
      135deg,
      var(--forest-green),
      var(--dark-brown)
    );
  }

  .non-dramione-section {
    background: linear-gradient(
      135deg,
      var(--emerald),
      var(--sage)
    );
  }

  /* Tab Navigation */
  .tab-navigation {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
    border-bottom: 2px solid var(--sage);
    padding-bottom: 0;
  }

  .tab-btn {
    padding: 0.75rem 1.5rem;
    border: none;
    background: transparent;
    color: var(--aged-paper);
    font-family: 'Georgia', serif;
    font-size: 1rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    cursor: pointer;
    border-bottom: 3px solid transparent;
    transition: all 0.3s ease;
    position: relative;
    top: 2px;
  }

  .tab-btn:hover {
    color: var(--antique-gold);
    background: rgba(74, 124, 89, 0.1);
  }

  .tab-btn.active {
    color: var(--antique-gold);
    border-bottom-color: var(--antique-gold);
    font-weight: 600;
  }

  /* Tab Content */
  .tab-content {
    display: none;
  }

  .tab-content.active {
    display: block;
  }

  /* Typeset Item Styling */
  #typesets-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 1.5rem;
  }

  .typeset-item {
    background: linear-gradient(
      to bottom,
      var(--forest-green),
      var(--dark-brown)
    );
    border: 2px solid var(--sage);
    border-radius: 0.5rem;
    padding: 1.5rem;
    aspect-ratio: 1 / 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    box-shadow:
      0 4px 12px rgba(0, 0, 0, 0.6),
      inset 0 1px 0 rgba(74, 124, 89, 0.2);
  }

  .typeset-item h3 {
    margin: 0 0 0.25rem;
    font-size: 1.3rem;
    color: var(--antique-gold);
    font-family: 'Georgia', serif;
    font-weight: 600;
  }

  .typeset-item h3 a {
    transition: all 0.2s ease;
  }

  .typeset-item h3 a:hover {
    color: var(--parchment);
    text-shadow: 0 0 8px rgba(201, 169, 97, 0.4);
  }

  .typeset-item .meta {
    color: var(--aged-paper);
  }
</style>


</head>
<body>
  <!-- Christmas Lights -->
  <div class="christmas-lights">
    <div class="light red"></div>
    <div class="light green"></div>
    <div class="light yellow"></div>
    <div class="light blue"></div>
    <div class="light red"></div>
    <div class="light green"></div>
    <div class="light yellow"></div>
    <div class="light blue"></div>
    <div class="light red"></div>
    <div class="light green"></div>
    <div class="light yellow"></div>
    <div class="light blue"></div>
  </div>

  <h1>Book Club EPUB Library</h1>
  <p style="margin-top: -0.4rem; margin-bottom: 0.25rem; font-size: 0.95rem; color: var(--aged-paper); font-family: 'Georgia', serif;">
  Hosted by <strong style="color: var(--antique-gold);">Cort</strong>, <strong style="color: var(--antique-gold);">Dey</strong>, <strong style="color: var(--antique-gold);">Lexi</strong>, and <strong style="color: var(--antique-gold);">Senna</strong>
</p>
  <p style="margin-top: 0; margin-bottom: 0.5rem; font-size: 0.9rem; color: var(--aged-paper); font-family: 'Georgia', serif;">
  Join our <a href="https://discord.com/invite/VTf22WVV4w" target="_blank" rel="noopener noreferrer">Book Club Discord</a>. Where we get up to all kinds of Dramione Shenanigans
</p>

  <!-- Tab Navigation -->
  <div class="tab-navigation">
    <button class="tab-btn active" data-tab="library">Library</button>
    <button class="tab-btn" data-tab="typesets">Typesets</button>
  </div>

  <!-- Library Tab Content -->
  <div id="library-tab" class="tab-content active">
    <p class="library-count" id="libraryCount">Loading library...</p>
  <div class="search-area">
    <label for="searchInput"><strong>Search</strong> (title, author, tags, etc.):</label><br />
    <input id="searchInput" type="text" placeholder="Start typing: drarry, coffee shop, author name..." />
    <p style="font-size:0.9rem; color: var(--aged-paper); margin-top:0.35rem; margin-bottom: 0.75rem;">
      This search looks at Title, Author, Main Relationship, Summary, and Tags
    </p>

    <div style="display: flex; gap: 1rem; margin-top: 0.5rem; flex-wrap: wrap;">
      <div style="flex: 1; min-width: 150px;">
        <label for="wordCountFilter" style="font-size: 0.85rem;"><strong>Word Count:</strong></label>
        <select id="wordCountFilter" style="width: 100%; font-size: 0.75rem;">
          <option value="all">All</option>
          <option value="under20k">Under 20k</option>
          <option value="20k-50k">20k - 50k</option>
          <option value="50k-100k">50k - 100k</option>
          <option value="100k-200k">100k - 200k</option>
          <option value="over200k">Over 200k</option>
        </select>
      </div>

      <div style="flex: 1; min-width: 150px;">
        <label for="relationshipFilter" style="font-size: 0.85rem;"><strong>Relationship:</strong></label>
        <select id="relationshipFilter" style="width: 100%; font-size: 0.75rem;">
          <option value="all">All</option>
          <option value="dramione">Dramione</option>
          <option value="drarry">Drarry</option>
          <option value="pansmione">Pansmione</option>
          <option value="theomione">Theomione</option>
          <option value="tomione">Tomione</option>
          <option value="pansville">Pansville</option>
          <option value="nottpott">NottPott</option>
          <option value="other">Other</option>
        </select>
      </div>

      <div style="flex: 1; min-width: 150px;">
        <label for="tropeFilter" style="font-size: 0.85rem;"><strong>Tag:</strong></label>
        <select id="tropeFilter" style="width: 100%; font-size: 0.75rem;">
          <option value="all">All</option>
          <!-- Popular tags will be added dynamically -->
        </select>
      </div>
    </div>

    <div style="margin-top: 0.75rem;">
      <label style="display: inline-flex; align-items: center; cursor: pointer;">
        <input type="checkbox" id="cortRecsFilter" style="width: auto; margin-right: 0.5rem; cursor: pointer;" />
        <strong>Cort Recs Only</strong>
      </label>
    </div>

    <div style="margin-top: 0.75rem;">
      <button class="random-btn" id="randomBtn" style="float: left; margin-right: 0.5rem;">üé≤ random rec</button>
      <button class="random-btn" id="clearBtn">‚úï clear filters</button>
      <div style="clear: both;"></div>
    </div>
  </div>

  <!-- Featured Lists -->
  <div class="featured-section dramione-section">
    <h3>This Months Dramione Buddy Read</h3>
    <div id="dramioneList"></div>
  </div>

  <div class="featured-section non-dramione-section">
    <h3>This Months Non Dramione Buddy Read</h3>
    <div id="nonDramioneList"></div>
  </div>

  <div id="resultsCount" style="color: var(--aged-paper); margin-bottom: 1rem; font-style: italic;"></div>
  <div id="results"></div>
  </div>

  <!-- Typesets Tab Content -->
  <div id="typesets-tab" class="tab-content">
    <h2 style="color: var(--antique-gold); margin-bottom: 1rem;">Typesets Collection</h2>
    <p style="color: var(--aged-paper); margin-bottom: 1rem;">
      Browse our collection of beautifully typeset PDFs. Click on any title to view or download.
    </p>
    <p style="color: var(--aged-paper); margin-bottom: 2rem;">
      <strong style="color: var(--antique-gold);">‚ö†Ô∏è Personal Use Only:</strong> These are for personal use only. If I find out you are selling or distributing my typesets in any way that displeases me, I will hire an etsy witch to curse you. Proceed with caution. <span style="font-style: italic; font-size: 1.1em;">xoxo <span style="font-family: 'Brush Script MT', 'Lucida Handwriting', cursive; font-size: 1.3em; color: var(--antique-gold);">Senna</span> üíöüêç</span>
    </p>

    <div id="typesets-list">
      <!-- Typesets will be loaded dynamically -->
    </div>
  </div>

  <script>
  // üîó Your published Google Sheet (TSV)
  const SHEET_URL =
    "https://docs.google.com/spreadsheets/d/e/2PACX-1vTDrnZp9JF0MARMOJRZYdAEjNj9gB5RnTNcYKIAwA2Grf41H5wQ9OQY7fNH7xE727mkvYkM4nhR56QZ/pub?gid=162465043&single=true&output=tsv";

  // üìö This will hold all your fics from the sheet
  let library = [];

  // üîó Grab elements from the page
  const resultsContainer = document.getElementById("results");
  const searchInput = document.getElementById("searchInput");
  const cortsFilter = document.getElementById("cortsFilter"); // ok if this doesn't exist
  const wordCountFilter = document.getElementById("wordCountFilter");
  const relationshipFilter = document.getElementById("relationshipFilter");
  const cortRecsFilter = document.getElementById("cortRecsFilter");
  const tropeFilter = document.getElementById("tropeFilter");

  // Tags to exclude from trope filter
  const EXCLUDED_FROM_TROPES = new Set([
    'f/m', 'm/m', 'f/f', 'm/f',
    'no archive warnings apply',
    'choose not to use archive warnings',
    'explicit sexual content',
    'graphic depictions of violence',
    'major character death',
    'rape/non-con',
    'underage'
  ]);

  // Character first names for filtering
  const CHARACTER_FIRST_NAMES = new Set([
    'harry', 'hermione', 'draco', 'ron', 'ginny', 'luna', 'neville',
    'pansy', 'theo', 'blaise', 'daphne', 'astoria', 'lavender', 'parvati',
    'tom', 'voldemort', 'snape', 'severus', 'lucius', 'narcissa',
    'sirius', 'remus', 'james', 'lily', 'albus', 'dumbledore', 'minerva',
    'tonks', 'fleur', 'bill', 'charlie', 'fred', 'george', 'percy',
    'hagrid', 'dobby', 'kreacher', 'fenrir', 'bellatrix', 'regulus',
    'cedric', 'viktor', 'cho', 'dean', 'seamus', 'colin', 'dennis',
    'molly', 'arthur', 'andromeda', 'ted', 'horace', 'gilderoy',
    'quirinus', 'mad-eye', 'barty', 'myrtle', 'moaning',
    'peeves', 'argus', 'sybill', 'gellert', 'newt', 'credence',
    'nagini', 'queenie', 'tina', 'jacob', 'theseus', 'scorpius'
  ]);

  const CHARACTER_LAST_NAMES = new Set([
    'potter', 'granger', 'weasley', 'malfoy', 'lovegood', 'longbottom',
    'parkinson', 'nott', 'zabini', 'greengrass', 'patil', 'brown',
    'riddle', 'snape', 'dumbledore', 'mcgonagall', 'black', 'lupin',
    'tonks', 'delacour', 'diggory', 'krum', 'chang', 'thomas', 'finnigan',
    'creevey', 'prewett', 'lestrange', 'crouch', 'moody', 'filch',
    'trelawney', 'slughorn', 'lockhart', 'quirrell', 'grindelwald',
    'scamander', 'goldstein', 'umbridge', 'fudge', 'shacklebolt',
    'vance', 'bones', 'abbott', 'macmillan', 'smith', 'corner',
    'boot', 'turpin', 'brocklehurst', 'carrow', 'yaxley', 'dolohov',
    'rookwood', 'avery', 'mulciber', 'rosier', 'wilkes', 'travers'
  ]);

  // Check if a tag is JUST a character name (without descriptors)
  function isPlainCharacterName(tag) {
    const normalized = tag.toLowerCase().trim();
    const words = normalized.split(/\s+/);

    // Single word - check if it's a known first name
    if (words.length === 1) {
      return CHARACTER_FIRST_NAMES.has(words[0]);
    }

    // Two words - check if it's "FirstName LastName"
    if (words.length === 2) {
      const [first, last] = words;
      if (CHARACTER_FIRST_NAMES.has(first) && CHARACTER_LAST_NAMES.has(last)) {
        return true;
      }
      // Also check for two first names like "Harry Ron"
      if (CHARACTER_FIRST_NAMES.has(first) && CHARACTER_FIRST_NAMES.has(last)) {
        return true;
      }
    }

    // Three words - check if it's "FirstName MiddleName LastName"
    if (words.length === 3) {
      const [first, middle, last] = words;
      if ((CHARACTER_FIRST_NAMES.has(first) || CHARACTER_FIRST_NAMES.has(middle)) &&
          CHARACTER_LAST_NAMES.has(last)) {
        return true;
      }
    }

    return false;
  }

  // üßπ Safely lowercase text
  function normalize(value) {
    return (value || "").toString().toLowerCase();
  }

  // üéØ Does this fic match the search text?
  function matchesQuery(item, query) {
    if (!query) return true;
    const q = normalize(query);

    return (
      normalize(item.title).includes(q) ||
      normalize(item.author).includes(q) ||
      normalize(item.mainRelationship).includes(q) ||
      normalize(item.summary).includes(q) ||
      normalize((item.tags || []).join(" ")).includes(q) ||
      normalize(item.cortsTiktokRecs).includes(q)
    );
  }

  // (optional) extra filtering for Cort's recs
  function matchesCortsFilter(item) {
    // Check the checkbox filter
    if (cortRecsFilter && cortRecsFilter.checked) {
      // Treat anything not FALSE/empty as a rec
      return normalize(item.cortsTiktokRecs) && normalize(item.cortsTiktokRecs) !== "false";
    }

    // Legacy dropdown support (if it exists)
    if (!cortsFilter || !cortsFilter.value || cortsFilter.value === "all") {
      return true;
    }

    if (cortsFilter.value === "corts-only") {
      return normalize(item.cortsTiktokRecs) && normalize(item.cortsTiktokRecs) !== "false";
    }

    return true;
  }

  // üìä Word count filter
  function matchesWordCountFilter(item) {
    if (!wordCountFilter || !wordCountFilter.value || wordCountFilter.value === "all") {
      return true;
    }

    // Parse word count from string (e.g., "123,456" or "123456")
    const wordCount = parseInt((item.words || "").replace(/,/g, ""));
    if (isNaN(wordCount)) return false;

    const filter = wordCountFilter.value;
    if (filter === "under20k") return wordCount < 20000;
    if (filter === "20k-50k") return wordCount >= 20000 && wordCount < 50000;
    if (filter === "50k-100k") return wordCount >= 50000 && wordCount < 100000;
    if (filter === "100k-200k") return wordCount >= 100000 && wordCount < 200000;
    if (filter === "over200k") return wordCount >= 200000;

    return true;
  }

  // üíï Relationship filter
  function matchesRelationshipFilter(item) {
    if (!relationshipFilter || !relationshipFilter.value || relationshipFilter.value === "all") {
      return true;
    }

    const filter = relationshipFilter.value;

    // Split by comma to get individual pairings (e.g., "Hermione/Draco, Pansy/Harry")
    const relationships = (item.mainRelationship || "").split(",").map(r => r.trim());

    // Check if any of the pairings match the selected filter
    return relationships.some(rel => {
      const relLower = normalize(rel);

      if (filter === "dramione") {
        return relLower.includes("draco") && relLower.includes("hermione");
      }
      if (filter === "drarry") {
        return relLower.includes("draco") && relLower.includes("harry");
      }
      if (filter === "pansmione") {
        return relLower.includes("pansy") && relLower.includes("hermione");
      }
      if (filter === "theomione") {
        return relLower.includes("theo") && relLower.includes("hermione");
      }
      if (filter === "tomione") {
        return relLower.includes("tom") && relLower.includes("hermione");
      }
      if (filter === "pansville") {
        return relLower.includes("pansy") && relLower.includes("neville");
      }
      if (filter === "nottpott") {
        return relLower.includes("theo") && relLower.includes("harry");
      }
      if (filter === "other") {
        // Check if this specific pairing is NOT one of the common ships
        const isDramione = relLower.includes("draco") && relLower.includes("hermione");
        const isDrarry = relLower.includes("draco") && relLower.includes("harry");
        const isPansmione = relLower.includes("pansy") && relLower.includes("hermione");
        const isTheomione = relLower.includes("theo") && relLower.includes("hermione");
        const isTomione = relLower.includes("tom") && relLower.includes("hermione");
        const isPansville = relLower.includes("pansy") && relLower.includes("neville");
        const isNottPott = relLower.includes("theo") && relLower.includes("harry");
        return !isDramione && !isDrarry && !isPansmione && !isTheomione && !isTomione && !isPansville && !isNottPott;
      }

      return false;
    });
  }

  // üè∑Ô∏è Trope filter
  function matchesTropeFilter(item) {
    if (!tropeFilter || !tropeFilter.value || tropeFilter.value === "all") {
      return true;
    }

    const selectedTrope = tropeFilter.value.toLowerCase();
    const itemTags = (item.tags || []).map(t => normalize(t));

    return itemTags.includes(selectedTrope);
  }

  // üé≠ Check if fic is Dramione
  function isDramione(item) {
    const rel = normalize(item.mainRelationship);
    return rel.includes("draco") && rel.includes("hermione");
  }

  // ‚≠ê Render featured lists
  function renderFeaturedLists() {
    const dramioneContainer = document.getElementById("dramioneList");
    const nonDramioneContainer = document.getElementById("nonDramioneList");

    if (!dramioneContainer || !nonDramioneContainer || !library.length) return;

    // Filter fics based on spreadsheet columns
    const dramioneFics = library.filter(item => {
      const value = normalize(item.dramioneBuddyRead).trim();
      return value === "true";
    });

    const nonDramioneFics = library.filter(item => {
      const value = normalize(item.nonDramioneBuddyRead).trim();
      return value === "true";
    });

    // Render all matching fics
    dramioneContainer.innerHTML = dramioneFics.length
      ? dramioneFics.map(item => renderFicCard(item)).join("")
      : '<p class="empty">No buddy read selected yet.</p>';

    nonDramioneContainer.innerHTML = nonDramioneFics.length
      ? nonDramioneFics.map(item => renderFicCard(item)).join("")
      : '<p class="empty">No buddy read selected yet.</p>';
  }

  // üé¥ Render a single fic card
  function renderFicCard(item) {
    const titleHtml = item.linkOnServer
      ? `<a href="${item.linkOnServer}" target="_blank" rel="noopener noreferrer">${item.title}</a>`
      : item.title;

    const tagsHtml =
      item.tags && item.tags.length
        ? item.tags.map((t) => `<span class="tag">${t}</span>`).join(" ")
        : "";

    const cortValue = normalize(item.cortsTiktokRecs).trim();
    const isCortRec = cortValue === "true";

    const cortsHtml = isCortRec
      ? `<div class="corts"><img src="images/cortrec-darkgreen-transparent-cropped.png" alt="Cort Rec" class="cort-badge"></div>`
      : "";

    return `
      <article class="fic">
        <h2>${titleHtml}</h2>
        <div class="meta">
          <span><strong>Author:</strong> ${item.author || "Unknown"}</span>
          <span><strong>Words:</strong> ${item.words || "?"}</span>
          <span><strong>Chapters:</strong> ${item.chapters || "?"}</span>
          <span><strong>Main Relationship:</strong> ${item.mainRelationship || "‚Äî"}</span>
        </div>
        <p class="summary">${item.summary || ""}</p>
        <div class="tags">${tagsHtml}</div>
        ${cortsHtml}
      </article>
    `;
  }

  // üñºÔ∏è Render the fic list into the page
  function renderResults(items) {
    if (!resultsContainer) return;

    const resultsCountEl = document.getElementById("resultsCount");

    if (!items.length) {
      resultsContainer.innerHTML =
        '<p class="empty">No results. Try a different search term.</p>';
      if (resultsCountEl) resultsCountEl.innerHTML = "";
      return;
    }

    const html = items.map(item => renderFicCard(item)).join("");
    resultsContainer.innerHTML = html;

    // Update results count
    if (resultsCountEl) {
      const countText = items.length === 1 ? "1 result" : `${items.length} results`;
      resultsCountEl.innerHTML = countText;
    }
  }
  // üé≤ Pick up to "count" random items from an array
  function getRandomItems(items, count) {
    const copy = [...items]; // shallow copy so we don't mutate the original

    // Fisher‚ÄìYates shuffle
    for (let i = copy.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }

    return copy.slice(0, Math.min(count, copy.length));
  }

  // üîé Apply search + Cort's filter + word count filter to the library and show results
  function applyFilters() {
    if (!library.length) {
      // no data yet
      if (resultsContainer) {
        resultsContainer.innerHTML = "<p class='empty'>Loading‚Ä¶</p>";
      }
      return;
    }

    const query = searchInput ? searchInput.value.trim() : "";
    const dramioneSection = document.querySelector(".dramione-section");
    const nonDramioneSection = document.querySelector(".non-dramione-section");
    const hasWordCountFilter = wordCountFilter && wordCountFilter.value !== "all";
    const hasRelationshipFilter = relationshipFilter && relationshipFilter.value !== "all";
    const hasCortRecsFilter = cortRecsFilter && cortRecsFilter.checked;
    const hasTropeFilter = tropeFilter && tropeFilter.value !== "all";

    // Always respect all filters first
    let filtered = library.filter((item) => matchesCortsFilter(item) && matchesWordCountFilter(item) && matchesRelationshipFilter(item) && matchesTropeFilter(item));

    if (query || hasWordCountFilter || hasRelationshipFilter || hasCortRecsFilter || hasTropeFilter) {
      // If there's a search term or any filter: hide buddy read sections and show search results
      if (dramioneSection) dramioneSection.style.display = "none";
      if (nonDramioneSection) nonDramioneSection.style.display = "none";

      if (query) {
        filtered = filtered.filter((item) => matchesQuery(item, query));
      }
      renderResults(filtered);
    } else {
      // If search box is empty and no filters: show buddy read sections and show 5 random fics
      if (dramioneSection) dramioneSection.style.display = "block";
      if (nonDramioneSection) nonDramioneSection.style.display = "block";

      const randomFive = getRandomItems(filtered, 5);
      renderResults(randomFive);

      // Clear the count display when showing default view
      const resultsCountEl = document.getElementById("resultsCount");
      if (resultsCountEl) resultsCountEl.innerHTML = "";
    }
  }


  // üì• Load data from the Google Sheet
  async function loadSheetData() {
    console.log("Fetching sheet from:", SHEET_URL);
    const response = await fetch(SHEET_URL);

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status} ${response.statusText}`);
    }

    const text = await response.text();
    console.log("Raw sheet text (first 200 chars):", text.slice(0, 200));

    const rows = text
      .trim()
      .split("\n")
      .map((row) => row.split("\t"));

    const [headerRow, ...dataRows] = rows;
    console.log("Headers:", headerRow);

    library = dataRows
      .map((cols) => {
        const [
          title,
          linkOnServer,
          author,
          words,
          chapters,
          mainRelationship,
          summary,
          tags,
          cortsTiktokRecs,
          dramioneBuddyRead,
          nonDramioneBuddyRead,
        ] = cols;

        return {
          title: title || "",
          linkOnServer: linkOnServer || "",
          author: author || "",
          words: words || "",
          chapters: chapters || "",
          mainRelationship: mainRelationship || "",
          summary: summary || "",
          tags: tags ? tags.split(",").map((t) => t.trim()) : [],
          cortsTiktokRecs: cortsTiktokRecs || "",
          dramioneBuddyRead: dramioneBuddyRead || "",
          nonDramioneBuddyRead: nonDramioneBuddyRead || "",
        };
      })
      .filter((item) => item.title && item.title.trim() !== "");

    console.log("Loaded items:", library.length);
    // Debug: Show the first few items and their cortsTiktokRecs values
    console.log("First 3 items with cortsTiktokRecs values:");
    library.slice(0, 3).forEach((item, idx) => {
      console.log(`  [${idx}] ${item.title}: cortsTiktokRecs = "${item.cortsTiktokRecs}"`);
    });

    // Update library count display
    const libraryCountEl = document.getElementById("libraryCount");
    if (libraryCountEl) {
      libraryCountEl.innerHTML = `Our library contains <strong>${library.length}</strong> ${library.length === 1 ? 'fic' : 'fics'}`;
    }

    // Populate trope filter with top 15 tropes
    populateTropeFilter();
  }

  // üè∑Ô∏è Populate the trope filter dropdown with top 15 tropes
  function populateTropeFilter() {
    if (!tropeFilter || !library.length) return;

    // Count all tags, excluding archive warnings, relationship types, and plain character names
    const tagCounts = {};

    library.forEach(item => {
      (item.tags || []).forEach(tag => {
        if (!tag) return;
        const normalized = normalize(tag);

        // Skip excluded tags (archive warnings, relationship types)
        if (EXCLUDED_FROM_TROPES.has(normalized)) return;

        // Skip plain character names (but keep descriptive tags like "BAMF Hermione Granger")
        if (isPlainCharacterName(tag)) return;

        tagCounts[tag] = (tagCounts[tag] || 0) + 1;
      });
    });

    // Sort by count and get top 15
    const topTropes = Object.entries(tagCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 15);

    // Add options to dropdown
    topTropes.forEach(([tag, count]) => {
      const option = document.createElement('option');
      option.value = tag.toLowerCase();
      option.textContent = `${tag} (${count})`;
      tropeFilter.appendChild(option);
    });

    console.log('Top 15 tropes loaded:', topTropes.map(([tag]) => tag));
  }

  // üîÅ Wire up events
if (searchInput) {
  const triggerFilter = () => {
    applyFilters();
  };

  // Fire filters for a bunch of interaction types (better mobile support)
  ["input", "keyup", "change", "search"].forEach((evt) => {
    searchInput.addEventListener(evt, triggerFilter);
  });
}

if (cortsFilter) {
  cortsFilter.addEventListener("change", () => {
    applyFilters();
  });
}

if (wordCountFilter) {
  wordCountFilter.addEventListener("change", () => {
    applyFilters();
  });
}

if (relationshipFilter) {
  relationshipFilter.addEventListener("change", () => {
    applyFilters();
  });
}

if (cortRecsFilter) {
  cortRecsFilter.addEventListener("change", () => {
    applyFilters();
  });
}

if (tropeFilter) {
  tropeFilter.addEventListener("change", () => {
    applyFilters();
  });
}

// üé≤ Random Rec Button
const randomBtn = document.getElementById("randomBtn");
if (randomBtn) {
  randomBtn.addEventListener("click", () => {
    if (!library.length) return;

    // Clear search box but keep filters
    if (searchInput) {
      searchInput.value = "";
    }

    // Hide buddy read sections
    const dramioneSection = document.querySelector(".dramione-section");
    const nonDramioneSection = document.querySelector(".non-dramione-section");
    if (dramioneSection) dramioneSection.style.display = "none";
    if (nonDramioneSection) nonDramioneSection.style.display = "none";

    // Apply filters to library before getting random fic
    let filtered = library.filter((item) => matchesCortsFilter(item) && matchesWordCountFilter(item) && matchesRelationshipFilter(item) && matchesTropeFilter(item));

    // Get a random fic from filtered results
    const randomFic = filtered[Math.floor(Math.random() * filtered.length)];

    // Show just this one fic
    renderResults([randomFic]);
  });
}

// ‚úï Clear Filters Button
const clearBtn = document.getElementById("clearBtn");
if (clearBtn) {
  clearBtn.addEventListener("click", () => {
    // Clear search box
    if (searchInput) {
      searchInput.value = "";
    }
    // Reset word count filter
    if (wordCountFilter) {
      wordCountFilter.value = "all";
    }
    // Reset relationship filter
    if (relationshipFilter) {
      relationshipFilter.value = "all";
    }
    // Reset trope filter
    if (tropeFilter) {
      tropeFilter.value = "all";
    }
    // Reset cort's filter if it exists
    if (cortsFilter) {
      cortsFilter.value = "all";
    }
    // Uncheck Cort Recs checkbox
    if (cortRecsFilter) {
      cortRecsFilter.checked = false;
    }

    // Reapply filters (which will show buddy read sections and random 5 fics)
    applyFilters();
  });
}

document.addEventListener("DOMContentLoaded", async () => {
  await loadSheetData();
  renderFeaturedLists();
  applyFilters();
});

// üìë Tab Switching Functionality
const tabButtons = document.querySelectorAll('.tab-btn');
const tabContents = document.querySelectorAll('.tab-content');

// Password for Typesets tab
const TYPESETS_PASSWORD = 'ChaosPuppy'; // Change this to your desired password
let isTypesetsUnlocked = localStorage.getItem('typesetsUnlocked') === 'true';

function switchTab(targetTab) {
  // Check if trying to access Typesets tab
  if (targetTab === 'typesets' && !isTypesetsUnlocked) {
    const password = prompt('Enter password to access Typesets:');
    if (password === TYPESETS_PASSWORD) {
      isTypesetsUnlocked = true;
      localStorage.setItem('typesetsUnlocked', 'true');
    } else {
      alert('Incorrect password');
      return; // Don't switch tabs
    }
  }

  // Remove active class from all buttons and contents
  tabButtons.forEach(btn => btn.classList.remove('active'));
  tabContents.forEach(content => content.classList.remove('active'));

  // Add active class to target button and corresponding content
  const targetButton = document.querySelector(`[data-tab="${targetTab}"]`);
  const targetContent = document.getElementById(`${targetTab}-tab`);

  if (targetButton && targetContent) {
    targetButton.classList.add('active');
    targetContent.classList.add('active');
    // Save current tab to localStorage
    localStorage.setItem('activeTab', targetTab);
  }
}

tabButtons.forEach(button => {
  button.addEventListener('click', () => {
    const targetTab = button.getAttribute('data-tab');
    switchTab(targetTab);
  });
});

// Restore active tab on page load
const savedTab = localStorage.getItem('activeTab');
if (savedTab) {
  switchTab(savedTab);
}

// üìö Typesets Loader
const typesets = [
  'apostasy.Deydralinne.12sign.9pgs.ssbinding.pdf',
  'bloodysluttypathetic.whatmurdah.11sign.8pgs.SSBinding.pdf',
  'finding_hermione.Ebookdragon.23Sign.8Pgs.SSBinding.pdf',
  'hinkypunk.inkjinx.Quatro.5sign.2pgs.ssbinding.pdf',
  'keeper_of_the_moon.vol1.Stevie_Sunshine.16sign.7pgs.SSBinding.pdf',
  'love.and.other.historical.accidents.pacificrimbaud.11sign.10pgs.SSBinding.pdf',
  'ours_to_keep.Head_Over_Heels016.12Signs.7Pgs.SSBinding.pdf',
  'pretty_boy.Bremonster.6Signs.10PgsSSBinding.pdf',
  'remain_nameless.HeyJude19.18sign.9pgs.SSbinding.pdf',
  'secrets.and.masks.fullvolume.EmeraldSlytherin.40sign.8pgs.SSBinding.pdf',
  'the.rights.and.wrongs.series.tandem.LovesBitca8.22sign.10pgs.SSBinding.pdf',
  'the.rights.and.wrongs.series.tandem.vol.1.LovesBitca8.12sign.9pgs.SSBinding.pdf',
  'the.rights.and.wrongs.series.tandem.vol.2.LovesBitca.19sign.6pgs.SSBinding.pdf',
  'this.bitter.earth.ikorous.33Sign.8Page.SSbinding.pdf',
  'two.weddings.and.a.man.hunt.Deydralinne.Quatro.13sign.4pgs.SSBinding.pdf'
];

function parseTypesetFilename(filename) {
  // Remove .pdf extension
  const name = filename.replace('.pdf', '');
  const parts = name.split('.');

  // Extract title (everything before the author)
  let title = '';
  let author = '';
  let signatures = '';
  let pages = '';
  let binding = '';
  let bindingSize = '';

  // Find where author name likely starts (look for capitalized word or before numbers)
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];

    // Check if this part contains "sign" (signatures info)
    if (part.toLowerCase().includes('sign')) {
      signatures = part;
      // Everything before this is title + author (and possibly binding size)
      // Last word before signatures is likely author, but could be binding size
      if (i > 0) {
        const prevPart = parts[i - 1];
        // Check if previous part is a binding size (Quatro, etc)
        if (prevPart.toLowerCase() === 'quatro' || prevPart.toLowerCase() === 'folio' || prevPart.toLowerCase() === 'octavo') {
          bindingSize = prevPart;
          if (i > 1) {
            author = parts[i - 2]; // Keep underscores for author names
            title = parts.slice(0, i - 2).join(' ').replace(/_/g, ' ');
          }
        } else {
          author = prevPart; // Keep underscores for author names
          title = parts.slice(0, i - 1).join(' ').replace(/_/g, ' ');
        }
      }
      // Get remaining info
      if (i + 1 < parts.length) {
        pages = parts[i + 1];
      }
      if (part.toLowerCase().includes('ssbinding') || (i + 2 < parts.length && parts[i + 2].toLowerCase().includes('ssbinding'))) {
        binding = 'Senna Slytherin binding';
      }
      break;
    }
  }

  // Parse signature count
  const sigMatch = signatures.match(/(\d+)sign/i);
  const sigCount = sigMatch ? sigMatch[1] : '';

  // Parse pages
  const pgsMatch = pages.match(/(\d+)pgs/i);
  const pgsCount = pgsMatch ? pgsMatch[1] : '';

  // Format title (capitalize words)
  title = title.split(' ').map(word =>
    word.charAt(0).toUpperCase() + word.slice(1)
  ).join(' ');

  // Format binding size
  if (bindingSize) {
    bindingSize = bindingSize.charAt(0).toUpperCase() + bindingSize.slice(1);
  }

  return {
    filename,
    title: title || 'Untitled',
    author: author || 'Unknown Author',
    signatures: sigCount,
    pages: pgsCount,
    binding,
    bindingSize
  };
}

function renderTypesets() {
  const container = document.getElementById('typesets-list');
  if (!container) return;

  const html = typesets.map(filename => {
    const info = parseTypesetFilename(filename);

    let metaParts = [];
    if (info.bindingSize) metaParts.push(info.bindingSize);
    if (info.signatures) metaParts.push(`${info.signatures} signatures`);
    if (info.pages) metaParts.push(`${info.pages} pages per signature`);
    if (info.binding) metaParts.push(info.binding);

    const metaText = metaParts.join(' ‚Ä¢ ');

    return `
      <div class="typeset-item">
        <h3><a href="typesets/${info.filename}" target="_blank">${info.title}</a></h3>
        <p class="meta" style="margin-top: 0; margin-bottom: 0.5rem;">by ${info.author}</p>
        <p class="meta">${metaText}</p>
      </div>
    `;
  }).join('');

  container.innerHTML = html;
}

// Load typesets when page loads
renderTypesets();

  </script>
</body>
</html>


